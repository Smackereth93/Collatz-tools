<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collatz Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
            max-width: 900px;
            margin: auto;
        }
        .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        .animation-container {
            flex: 1.4;
        }
        .controls {
            flex: 1;
            text-align: left;
            padding-left: 20px;
        }
        canvas {
            border: 1px solid black;
            background-color: white;
        }
        input, button {
            padding: 10px;
            margin: 5px 0;
            font-size: 16px;
            width: 100%;
        }
        .section {
            margin-top: 40px;
            padding: 20px;
            border-top: 2px solid black;
            text-align: left;
        }
    </style>
    <script defer src="https://vercel.com/analytics/script.js"></script>
</head>
<body>

    <h1>Tool 1: Collatz Visualization</h1>
    <p>A smoother python animation is also available, if you have any interesting proof ideas based on the animation or anything below or you would like any further explanation or information please feel free to email <a href="mailto:mackermaths@gmail.com">mackermaths@gmail.com</a>. This animation should not be reproduced or cited without permission and acknowledgement.</p>
    <p>
        This tool visualizes the Collatz Conjecture using a circular mapping system. Each full circle represents the interval between successive powers of 2 or 3, with numbers' positions around the circumference determined by their proportion of the way through the interval.
    </p>
    <p>
        This means that whereas under the operation 0.5(3n+1) numbers either map to a point further around in their current circle or a point close to the beginning of the next, they retain their position under division by 2. Thus, for large numbers, the pathway around the circle becomes very predictable, with the error from the +1 failing to make an impact on the base pattern of n*1.5^r around the circle.
    </p>
    <button onclick="toggleBase()">Switch to Base-3</button>
    
    <div class="container">
        <div class="animation-container">
            <canvas id="canvas" width="700" height="700"></canvas>
        </div>
        <div class="controls">
            <label>Enter a number:</label>
            <input type="number" id="numberInput" value="63728127" min="1">
            <button onclick="startAnimation()">Start</button>
            <button onclick="resetAnimation()">Reset</button>
            <label for="speedSlider">Speed (Delay):</label>
            <input type="range" id="speedSlider" min="0.00025" max="0.15" value="0.02" step="0.0025" oninput="updateSpeed()">
            <span id="speedValue">2.0</span>
        </div>
    </div>

    <script>
        let currentBase = 2;
        let animationFrame;
        let moveIndex = 0;
        let path = [];
        let running = false;
        let speed = 0.3;
        let number = 63728127;

        function toggleBase() {
            currentBase = currentBase === 2 ? 3 : 2;
            document.querySelector("button").textContent = currentBase === 2 ? "Switch to Base-3" : "Switch to Base-2";
            resetAnimation();
        }

        function drawCircle() {
            const labels = currentBase === 2 ? [
                { text: '2^n', x: 350, y: 60 },
                { text: '5·2^n', x: 650, y: 360 },
                { text: '6·2^n', x: 350, y: 660 },
                { text: '7·2^n', x: 50, y: 360 }
            ] : [
                { text: '3^n', x: 350, y: 60 },
                { text: '9·3^n', x: 650, y: 360 },
                { text: '6·3^n', x: 350, y: 660 }
            ];
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 280;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = '16px Arial';
            ctx.fillStyle = 'black';
            labels.forEach(label => {
                ctx.fillText(label.text, label.x, label.y);
            });
        }

        function computePath() {
            path = [];
            let n = number;
            while (n !== 1) {
                let power = Math.floor(Math.log(n) / Math.log(currentBase));
                let angle = (360 * (n - Math.pow(currentBase, power))) / Math.pow(currentBase, power);
                angle = (angle * Math.PI) / 180;
                let x = 350 + 280 * Math.sin(angle);
                let y = 350 - 280 * Math.cos(angle);
                path.push({ x, y });
                n = (n % 2 === 0) ? n / 2 : 3 * n + 1;
            }
            path.push({ x: 350, y: 350 });
        }

        function startAnimation() {
            if (running) return;
            number = parseInt(document.getElementById("numberInput").value);
            speed = parseFloat(parseFloat(document.getElementById("speedSlider").value));
            if (isNaN(number) || number <= 1) {
                alert("Please enter a positive integer greater than 1.");
                return;
            }
            running = true;
            moveIndex = 0;
            computePath();
            requestAnimationFrame(animateNumber);
        }

        function animateNumber() {
            if (!running || moveIndex >= path.length - 1) {
                running = false;
                return;
            }
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            drawCircle();
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i <= moveIndex; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.stroke();
            moveIndex++;
            setTimeout(() => { animationFrame = requestAnimationFrame(animateNumber); }, 1000 * speed);
        }

        function resetAnimation() {
            running = false;
            cancelAnimationFrame(animationFrame);
            drawCircle();
        }

        function updateSpeed() {
            speed = parseFloat(document.getElementById("speedSlider").value);
            document.getElementById("speedValue").textContent = speed;
        }

        drawCircle();
    </script>

    <h1>Tool 2: Pathway Polynomial Generator</h1>
    <p>This tool allows you to generate polynomial transformations based on a sequence of 'f' and 'g' operations. The starting polynomials are <strong>f(x) = k + 0</strong> and <strong>g(x) = k + 0</strong>, and each operation modifies the coefficients according to predefined rules. This tool helps visualize how the polynomials evolve under different transformation sequences.</p>
    <p>Enter a sequence of 'f' and 'g' operations to transform the starting polynomials.</p>
    <input type="text" id="operationInput" placeholder="Enter f/g sequence">
    <button onclick="calculatePolynomials()">Generate</button>
    <p id="polynomialOutput"></p>

    <script>
        function calculatePolynomials() {
            let operations = document.getElementById("operationInput").value.toLowerCase();
            let a = 1, b = 0, c = 1, d = 0;
            for (let op of operations) {
                if (op === 'f') {
                    if (d % 2 === 1) {
                        a *= 2; c *= 3; d = Math.floor(1.5 * d + 0.5);
                    } else {
                        b += a; a *= 2; d += c; d = Math.floor(1.5 * d + 0.5); c *= 3;
                    }
                } else if (op === 'g') {
                    if (d % 2 === 0) {
                        a *= 2; d /= 2;
                    } else {
                        b += a; a *= 2; d += c; d = Math.floor(d / 2);
                    }
                }
            }
            document.getElementById("polynomialOutput").innerText = `f(x): ${a}k + ${b}, g(x): ${c}k + ${d}`;
        }
    </script>
<div class="section">
        <h2>Proof Ideas & Hypothesis</h2>
        <p>
        Non-divergence: the proportion of halving steps in a number's pathway increases exponentially as we approach numbers just above a power of 2. All numbers under 2^k - 1 must contain at least one halving step in their 2-adic defined path, the bottom half at least 2, the bottom quarter at least 3 and so on. Initially a number can avoid too many halving steps to dip below itself but due to the ergodic nature of the pathway around the circle for high values of n it must cross into a high halving zone at some point, usually after 12 steps and within at least the bottom 1/2^n . This means that any arbitrarily long pathway must be of an arbitrarily large number, from here I hope to build a more formal proof that all numbers dip below thier initial value by considering the cumulative impact of this demand for halving steps.
        </p>
        <p>
        Non-looping: It can be shown using the polynomial generator above that an arbitrarily high proportion of numbers from each circle must drop below their initial value. This means that the angular error from the accumulated +1 steps will, at a certain point, be arbitrarily small. As the error from approximating log bas 2 of 3 is bounded by Baker's bound at a certain minimum value which actually increases exponentially in numerical value as our number of steps increases, the error from +1 can never catch up beyond a certain point, leaving numbers' pathways entirely dominated by the 3/2 multiplier until halving steps force them downwards. Loops for high values of n depend on the two errors matching, it is clear from the animated pathways of very large, very divergent numbers around the circle that the +1 error has almost no effect for large values. This also explains why larger numbers' pathway lengths only increase logarithmically.    
        </p>
    </div>
</body>
</html>
